<!DOCTYPE html>
<html lang="en">
 <head>
    <title>DS1302</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width initial-scale=1"/>
    <link rel="shortcut icon" type="image/x-icon" href="../../src/img/cover/cover_title.png"/>
    <!-- Prism -->
    <link rel="stylesheet" href="../../css/prism.css">
    <script src="../../js/prism.js"></script>
    <!-- 新 Bootstrap4 核心 CSS 文件 -->
    <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
    <!-- jQuery文件。务必在bootstrap.min.js 之前引入 -->
    <script src="https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js"></script>
    <!-- bootstrap.bundle.min.js 用于弹窗、提示、下拉菜单，包含了 popper.min.js -->
    <script src="https://cdn.staticfile.org/popper.js/1.15.0/umd/popper.min.js"></script>
    <!-- 最新的 Bootstrap4 核心 JavaScript 文件 -->
    <script src="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>
    <!-- My style.css-->
    <link rel="stylesheet" href="../../css/bootstrap-m-style.css">
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>

<a href="../index/singlechip.html">
<svg class="bi bi-arrow-left-square" width="3em" height="3em" viewBox="0 0 16 16" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
  <path fill-rule="evenodd" d="M14 1H2a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>
  <path fill-rule="evenodd" d="M8.354 11.354a.5.5 0 0 0 0-.708L5.707 8l2.647-2.646a.5.5 0 1 0-.708-.708l-3 3a.5.5 0 0 0 0 .708l3 3a.5.5 0 0 0 .708 0z"/>
  <path fill-rule="evenodd" d="M11.5 8a.5.5 0 0 0-.5-.5H6a.5.5 0 0 0 0 1h5a.5.5 0 0 0 .5-.5z"/>
</svg>
</a>

<br>
<div class="m-label">DS1302</div>
<pre><code class="language-html line-numbers">DS1302 是 DALLAS（达拉斯）公司推出的一款涓流充电时钟芯片，2001 年 DALLAS被 MAXIM（美信）收购，因此我们看到的 DS1302 的数据手册既有 DALLAS 的标志，又有MAXIM 的标志，大家了解即可。
DS1302 实时时钟芯片广泛应用于电话、传真、便携式仪器等产品领域，它的主要性能指标如下：
1、DS1302 是一个实时时钟芯片，可以提供秒、分、小时、日期、月、年等信息，并且还有软件自动调整的能力，可以通过配置 AM/PM来决定采用24小时格式还是12小时格式。
2、拥有 31 字节数据存储 RAM。
3、串行 I/O 通信方式，相对并行来说比较节省 IO 口的使用。
4、DS1302 的工作电压比较宽，在 2.0～5.5V 的范围内都可以正常工作。
5、DS1302 这种时钟芯片功耗一般都很低，它在工作电压 2.0V 的时候，工作电流小于300nA。
6、DS1302 共有 8 个引脚，有两种封装形式，一种是 DIP-8 封装，芯片宽度（不含引脚）是 300mil，一种是 SOP-8 封装，有两种宽度，一种是 150mil，一种是 208mil。我们看一下DS1302 的引脚封装图，如图 15-3 所示。
所谓的 DIP(Dual In-line Package)封装，就是双列直插式封装技术，就如同我们开发板上的 STC89C52 单片机，就是个典型的 DIP 封装，当然这个 STC89C52 还有其它的封装样式，为了方便学习使用，我们采用的是 DIP 封装。而 74HC245、74HC138、24C02、DS1302 我们用的都是 SOP(Small Out-Line Package)封装，是一种芯片两侧引出 L 形引脚的封装技术，大家可以看看开发板上的芯片，了解一下这些常识性知识。
7、当供电电压是 5V 的时候，兼容标准的 TTL 电平标准，这里的意思是，可以完美的和单片机进行通信。
8、由于 DS1302 是 DS1202 的升级版本，所以所有的功能都兼容 DS1202。此外 DS1302有两个电源输入，一个是主电源，另外一个是备用电源，比如可以用电池或者大电容，这样做是为了在系统掉电的情况下，我们的时钟还会继续走。如果使用的是充电电池，还可以在正常工作时，设置充电功能，给我们的备用电池进行充电。
DS1302 的特点第二条“拥有 31 字节数据存储 RAM”，这是 DS1302 额外存在的资源。
这 31 字节的 RAM 相当于一个存储器一样，我们编写单片机程序的时候，可以把我们想存储的数据存储在 DS1302 里边，需要的时候读出来，这块功能和 EEPROM 有点类似，相当于一个掉电丢失数据的“EEPROM”，如果我们的时钟电路加上备用电池，那么这 31 个字节的RAM 就可以替代 EEPROM 的功能了。这 31 字节的 RAM 功能使用很少，所以在这里我们就不讲了，大家了解即可。
</code></pre>

<img src="../../src/img/singlechip/ds1302-1.png">
<img src="../../src/img/singlechip/ds1302-2.png">

<pre>1 脚 VCC2 是主电源正极的引脚，2 脚 X1 和 3 脚 X2 是晶振输入和输出引脚，4 脚 GND是负极，5 脚 CE 是使能引脚，接单片机的 IO 口，6 脚 I/O 是数据传输引脚，接单片机的 IO口，7 脚 SCLK 是通信时钟引脚，接单片机的 IO 口，8 脚 VCC1 是备用电源引脚。考虑到KST-51 开发板是一套以学习为目的的板子，加上备用电池对航空运输和携带不方便，所以 8脚没有接备用电池，而是接了一个 10uF 的电容，这个电容就相当于一个电量很小的电池，经过试验测量得出其可以在系统掉电后仍维持 DS1302 运行 1 分钟左右，如果大家想运行时间再长，可以加大电容的容量或者换成备用电池，如果掉电后不需要它再维持运行，也可以干脆悬空，如图 15-7 和图 15-8 所示
</pre>

<img src="../../src/img/singlechip/ds1302-3.png">
<img src="../../src/img/singlechip/ds1302-4.png">
<img src="../../src/img/singlechip/ds1302-5.png">

<pre>DS1302 的一条指令一个字节共 8 位，其中第 7 位（即最高位）固定为 1，这一位如果是0 的话，那写进去也是无效的。第 6 位是选择 RAM 还是 CLOCK 的，我前边说过，我们这里主要讲 CLOCK 时钟的使用，它的 RAM 功能我们不用，所以如果选择 CLOCK 功能，第 6位是 0，如果要用 RAM，那第 6 位就是 1。从第 5 到第 1 位，决定了寄存器的 5 位地址，而第 0 位是读写位，如果要写，这一位就是 0，如果要读，这一位就是 1。指令字节直观位分配如图 所示
</pre>

<img src="../../src/img/singlechip/ds1302-6.png">

<pre>DS1302 时钟的寄存器，共9个  其中 8 个和时钟有关的，5 位地址分别是 0b00000～0b00111，还有一个寄存器的地址是 01000，这是涓流充电所用的寄存器，我们这里不讲。在 DS1302 的数据手册里的地址，直接把第 7 位、第 6 位和第 0 位值给出来了，所以指令就成了 0x80、0x81那些了，最低位是 1，那么表示读，最低位是 0 表示写，如图 15-10 所示  0 1 10 11 100 101 110 111 
</pre>

<img src="../../src/img/singlechip/ds1302-7.png">

<pre>寄存器 0：最高位 CH 是一个时钟停止标志位。如果时钟电路有备用电源，上电后，我们要先检测一下这一位，如果这一位是 0，那说明时钟芯片在系统掉电后，由于备用            
电源的供给，时钟是持续正常运行的；如果这一位是 1，那么说明时钟芯片在系统掉电后，时钟部分不工作了。如果 Vcc1 悬空或者是电池没电了，当我们下次重新上                                     
电时，读取这一位，那这一位就是 1，我们可以通过这一位判断时钟在单片机系统掉电后是否还正常运行。剩下的7 位高 3 位是秒的十位，低 4 位是秒的个位，这里
再提请注意一次，DS1302 内部是 BCD 码，而秒的十位最大是 5，所以 3 个二进制位就够了。
寄存器 1：最高位未使用，剩下的 7 位中高 3 位是分钟的十位，低 4 位是分钟的个位。
寄存器 2：bit7 是 1 的话代表是 12 小时制，0 代表是 24 小时制；bit6 固定是 0，bit5 在12 小时制下 0 代表的是上午，1 代表的是下午，在 24 小时制下和 bit4 一起代表了              
小时的十位，低 4 位代表的是小时的个位。
寄存器 3：高 2 位固定是 0，bit5 和 bit4 是日期的十位，低 4 位是日期的个位。
寄存器 4：高 3 位固定是 0，bit4 是月的十位，低 4 位是月的个位。
寄存器 5：高 5 位固定是 0，低 3 位代表了星期。
寄存器 6：高 4 位代表了年的十位，低 4 位代表了年的个位。请特别注意，这里的 00～99 指的是 2000 年～2099 年。
寄存器 7：最高位一个写保护位，如果这一位是 1，那么是禁止给任何其它寄存器或者那 31 个字节的 RAM 写数据的。因此在写数据之前，这一位必须先写成 0

15.3.4 DS1302 通信时序介绍
DS1302 我们前边也有提起过，是三根线，分别是 CE、I/O 和 SCLK，其中 CE 是使能线，SCLK 是时钟线，I/O 是数据线。前边我们介绍过了 SPI 通信，同学们发现没发现，这个 DS1302的通信线定义和 SPI 怎么这么像呢？
事实上，DS1302 的通信是 SPI 的变异种类，它用了 SPI 的通信时序，但是通信的时候没有完全按照 SPI 的规则来，下面我们一点点解剖 DS1302 的变异 SPI 通信方式。先看一下单字节写入操作，如图 15-11 所示

</pre>


<img src="../../src/img/singlechip/ds1302-8.png">

<p>再对比一下 CPOL=0/CPHA=0 情况下的 SPI 的操作时序</p>

<img src="../../src/img/singlechip/ds1302-9.png">

<pre>图 15-11 和图 15-12 的通信时序，其中 CE 和 SSEL 的使能控制是反的，对于通信写数据，都是在 SCK 的上升沿，从机进行采样，下降沿的时候，主机发送数据。DS1302 的时序里，单片机要预先写一个字节指令，指明要写入的寄存器的地址以及后续的操作是写操作，然后再写入一个字节的数据。
对于单字节读操作，我就不做对比了，把 DS1302 的时序图贴出来，大家自己看一下即可，如图 15-13 所示
</pre>

<img src="../../src/img/singlechip/ds1302-10.png">


<pre>
操作有两处需要特别注意的地方。第一，DS1302 的时序图上的箭头都是针对 DS1302来说的，因此读操作的时候，先写第一个字节指令，上升沿的时候 DS1302 来锁存数据，下降沿我们用单片机发送数据。到了第二个字数据，由于我们这个时序过程相当于CPOL=0/CPHA=0，前沿发送数据，后沿读取数据，第二个字节是 DS1302 下降沿输出数据，我们的单片机上升沿来读取，因此箭头从 DS1302 角度来说，出现在了下降沿。
第二个需要注意的地方就是，我们的单片机没有标准的 SPI 接口，和 I 2 C 一样需要用 IO口来模拟通信过程。在读 DS1302 的时候，理论上 SPI 是上升沿读取，但是程序是用 IO 口模拟的，所以数据的读取和时钟沿的变化不可能同时了，必然就有一个先后顺序。通过实验发现，如果先读取 IO 线上的数据，再拉高 SCLK 产生上升沿，那么读到的数据一定是正确的，而颠倒顺序后数据就有可能出错。这个问题产生的原因还是在于 DS1302 的通信协议与标准SPI 协议存在的差异造成的，如果是标准 SPI 的数据线，数据会一直保持到下一个周期的下降沿才会变化，所以读取数据和上升沿的先后顺序就无所谓了；但 DS1302 的 IO 线会在时钟上升沿后被 DS1302 释放，也就是撤销强推挽输出变为弱下拉状态，而此时在 51 单片机引脚内部上拉的作用下，IO 线上的实际电平会慢慢上升，从而导致在上升沿产生后再读取 IO 数据的话就可能会出错。因此这里的程序我们按照先读取 IO 数据，再拉高 SCLK 产生上升沿的顺序。

进行产品开发的时候，逻辑的严谨性非常重要，如果一个产品或者程序逻辑上不严谨，就有可能出现功能上的错误。比如我们 15.3.4 节里的这个程序，我们再回顾一下，当单片机定时器时间到了 200ms 后，我们连续把 DS1302 的时间参数的 7 个字节读了出来。但是不管怎么读，都会有一个时间差，在极端的情况下就会出现这样一种情况：假如我们当前的时间是 00:00:59，我们先读秒，读到的秒是 59，然后再去读分钟，而就在读完秒到还未开始读分钟的这段时间内，刚好时间进位了，变成了 00:01:00 这个时间，我们读到的分钟就是 01，显示在液晶上就会出现一个 00:01:59，这个时间很明显是错误的。出现这个问题的概率极小，但却是实实在在可能存在的。

为了解决这个问题，芯片厂家肯定要给我们提供一种解决方案，这就是 DS1302 的突发模式。突发模式也分为 RAM 突发模式和时钟突发模式，RAM 部分我们不讲，我们只看和时钟相关的 clock burst mode。

当我们写指令到DS1302的时候，只要我们将要写的5位地址全部写1，即读操作用0xBF，写操作用 0xBE，这样的指令送给 DS1302 之后，它就会自动识别出来是 burst 模式，马上把所有的 8 个字节同时锁存到另外的 8 个字节的寄存器缓冲区内，这样时钟继续走，而我们读数据是从另外一个缓冲区内读取的。同样的道理，如果我们用 burst 模式写数据，那么我们也是先写到这个缓冲区内，最终 DS1302 会把这个缓冲区内的数据一次性送到它的时钟寄存器内。
要注意的是，不管是读还是写，只要使用时钟的 burst 模式，则必须一次性读写 8 个寄存器，要把时钟的寄存器完全读出来或者完全写进去。
下边就提供一个 burst 模式的例程给大家学习一下，程序的功能还是与上一节一样的。

共用体也称之为联合体，共用体定义和结构体十分类似，我们同样是推荐以下形式：
union 共用体名
{
数据类型 1 成员名 1；
数据类型 2 成员名 2；
„„
数据类型 n 成员名 n；
};
union 共用体名 共用体变量;
共用体表示的是几个变量共用一个内存位置，也就是成员 1、成员 2„„成员 n 都用一个内存位置。
共用体成员的访问方式和结构体是一样的，成员访问的方式是：共用体名.成员名，使用指针来访问的方式是：共用体名->成员名。
共用体可以出现在结构体内，结构体也可以出现在共用体内，在我们编程的日常应用中，最多应用是结构体出现在共用体内，例如：
union
{
unsigned int value;
struct
{
unsigned char first;
unsigned char second;
} half;
} number;
这样将一个结构体定义到一个共用体内部，我们如果采用无符号整型赋值的时候，直接调用 value 这个变量，同时，我们也可以通过访问或赋值给 first 和 second 这两个变量来访问或修改 value 的高字节和低字节。
这样看起来似乎是可以高效率的在 int 型变量和它的高低字节之间切换访问，但请回想一下，我们在介绍数据指针的时候就曾提到过，多字节变量的字节序取决于单片机架构和编译器，并非是固定不变的，所以这种方式写好的程序代码在换到另一种单片机和编译环境后，就有可能是错的，从安全和可移植的角度来讲，这样的代码是存在隐患的，所以现在诸多以安全为首要诉求的 C 语言编程规范里干脆直接禁止使用共用体。我们虽然不禁止，但也不推荐你用，除非你清楚的了解你所使用的开发环境的实现细节。

共用体和结构体的主要区别如下：
1、结构体和共用体都是由多个不同的数据类型成员组成，但在任何一个时刻，共用体只能存放一个被选中的成员，而结构体所有的成员都存在。
2、对于共同体的不同成员的赋值，将会改变其它成员的值，而对于结构体不同成员的赋值是相互之间不影响的。
3 15.4.3 枚举数据类型
在实际问题中，有些变量的取值被限定在一个有限的范围内。例如，一个星期从周一到周日有 7 天，一年从 1 月到 12 月有 12 个月，蜂鸣器有响和不响两种状态等等。如果把这些变量定义成整型或者字符型不是很合适，因为这些变量都有自己的范围。C 语言提供了一种称为“枚举”的类型，在枚举类型的定义中列举出所有可能的值，并可以为每一个值取一个形象化的名字，它的这一特性可以提高程序代码的可读性。
枚举的说明形式如下：
enum 枚举名
{
标识符 1[=整型常数],
标识符 2[=整型常数],
„„
标识符 n[=整型常数]
};
enum 枚举名 枚举变量;
枚举的说明形式中，如果没有被初始化，那么“=整型常数”是可以被省略的，如果是默认值的话，从第一个标识符顺序赋值 0、1、2„„，但是当枚举中任何一个成员被赋值后，它后边的成员按照依次加 1 的规则确定数值。
枚举的使用，有几点要注意：
1、枚举中每个成员结束符是逗号，而不是分号，最后一个成员可以省略逗号。
2、枚举成员的初始化值可以是负数，但是后边的成员依然依次加 1。
3、枚举变量只能取枚举结构中的某个标识符常量，不可以在范围之外。
5 15.5 电子钟实例
共用体除非必要，否则我们不推荐使用，枚举的用法比较简单，在本书 19 章的项目实践中有很好的示例，这节课我们先来练习一下结构体的使用。下边这个程序的功能是一个带日期的电子钟，相当于一个简易万年历了，并且加入了按键调时功能。学有余力的同学看到这里，不妨先不看我们提供的代码，自己写写试试。如果能够独立写一个按键可调的万年历程序，单片机可以说基本入门了。如果自己还不能够独立完成这个程序，那么还是老规矩，
先抄并且理解，而后自己独立默写出来，并且要边默写边理解。
本例直接忽略了星期这项内容，通过上、下、左、右、回车、ESC 这 6 个按键可以调整时间。这也是一个具有综合练习性质的实例，虽然在功能实现上没有多少难度，但要进行的操作却比较多而且烦琐，同学们可以从中体会到把繁杂的功能实现分解为一步步函数操作的必要性以及方便灵活性。简单说一下这个程序的几个要点，方便大家阅读理解程序。
1、把 DS1302 的底层操作封装为一个 DS1302.c 文件，对上层应用提供基本的实时时间的操作接口，这个文件也是我们的又一个功能模块了，我们的积累也越来越多了。
2、定义一个结构体类型 sTime 用来封装日期时间的各个元素，又用该结构体定义了一个时间缓冲区变量 bufTime 来暂存从 DS1302 读出的时间和设置时间时的设定值。需要注意的是在其它文件中要使用这个结构体变量时，必须首先再声明一次 sTime 类型；
3、定义一个变量 setIndex 来控制当前是否处于设置时间的状态，以及设置时间的哪一位，该值为 0 就表示正常运行，1～12 分别代表可以修改日期时间的 12 个位；
4、由于这节课的程序功能要进行时间调整，用到了 1602 液晶的光标功能，添加了设置光标的函数，我们要改变哪一位的数字，就在 1602 对应位置上进行光标闪烁，所以 Lcd1602.c在之前文件的基础上添加了两个控制光标的函数；
5、时间的显示、增减、设置移位等上层功能函数都放在 main.c 中来实现，当按键需要这些函数时则在按键文件中做外部声明，这样做是为了避免一组功能函数分散在不同的文件内而使程序显得凌乱。

6 15.6 作业
1、理解 BCD 码的原理。
2、理解 SPI 的通信原理，SPI 通信过程的四种模式配置。
3、能够结合教程阅读 DS1302 的英文数据手册，学会 DS1302 的读写操作。
4、理解复合数据类型的结构和用法。
5、能够独立完成带按键功能的万年历程序。
</pre>



</body>
</html>