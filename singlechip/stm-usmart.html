<!DOCTYPE html>
<html lang="en">
 <head>
    <title>USMART</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width initial-scale=1"/>
    <link rel="shortcut icon" type="image/x-icon" href="../../src/img/cover/cover_title.png"/>
    <!-- Prism -->
    <link rel="stylesheet" href="../../css/prism.css">
    <script src="../../js/prism.js"></script>
    <!-- 新 Bootstrap4 核心 CSS 文件 -->
    <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
    <!-- jQuery文件。务必在bootstrap.min.js 之前引入 -->
    <script src="https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js"></script>
    <!-- bootstrap.bundle.min.js 用于弹窗、提示、下拉菜单，包含了 popper.min.js -->
    <script src="https://cdn.staticfile.org/popper.js/1.15.0/umd/popper.min.js"></script>
    <!-- 最新的 Bootstrap4 核心 JavaScript 文件 -->
    <script src="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>
    <!-- My style.css-->
    <link rel="stylesheet" href="../../css/bootstrap-m-style.css">
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>

<a href="../index/singlechip.html">
<svg class="bi bi-arrow-left-square" width="3em" height="3em" viewBox="0 0 16 16" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
  <path fill-rule="evenodd" d="M14 1H2a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>
  <path fill-rule="evenodd" d="M8.354 11.354a.5.5 0 0 0 0-.708L5.707 8l2.647-2.646a.5.5 0 1 0-.708-.708l-3 3a.5.5 0 0 0 0 .708l3 3a.5.5 0 0 0 .708 0z"/>
  <path fill-rule="evenodd" d="M11.5 8a.5.5 0 0 0-.5-.5H6a.5.5 0 0 0 0 1h5a.5.5 0 0 0 .5-.5z"/>
</svg>
</a>

<br>
<div class="m-label">USMART</div>
<pre>功能类似 linux 的 shell（RTT 的 finsh 也属于此类）。
USMART 最主要的功能就是通过串口调用单片机里面的函数，并执行

USMART 的实现流程简单概括就是：第一步，添加需要调用的函数（在 usmart_config.c 里
面的 usmart_nametab 数组里面添加）；第二步，初始化串口；第三步，初始化 USMART（通过
usmart_init 函数实现）；第四步，轮询 usmart_scan 函数，处理串口数据。

USMART 组件总共包含 6 文件如图 19.1.1 所示：</pre>

<img src="../../src/img/singlechip/stm-usmart-1.png">
<pre>usmart.c 负责与外部互交等。
usmat_str.c 主要负责命令和参数解析。usmart_config.c 主要由用户添加需要由 usmart 管理的函
数。
usmart.h 和 usmart_str.h 是两个头文件，其中 usmart.h 里面含有几个用户配置宏定义，可以
用来配置 usmart 的功能及总参数长度(直接和 SRAM 占用挂钩)、是否使能定时器扫描、是否使
用读写函数等。
USMART 的移植，只需要实现 5 个函数。其中 4 个函数都在 usmart.c 里面，另外一个是串
口接收函数，必须由用户自己实现，用于接收串口发送过来的数据。
第一个函数，串口接收函数。该函数，我们是通过 SYSTEM 文件夹默认的串口接收来实现
的，该函数在 5.3.1 节有介绍过，我们这里就不列出来了。SYSTEM 文件夹里面的串口接收函
数，最大可以一次接收 200 字节，用于从串口接收函数名和参数等。大家如果在其他平台移植，
请参考 SYSTEM 文件夹串口接收的实现方式进行移植。
第二个是 void usmart_init(void)函数，该函数的实现代码如下：
</pre>
<img src="../../src/img/singlechip/stm-usmart-2.png">
<pre>该函数有一个参数 sysclk，就是用于定时器初始化。另外 USMART_ENTIMX_SCAN 是在
usmart.h 里面定义的一个是否使能定时器中断扫描的宏定义。如果为 1，就初始化定时器中断，
并在中断里面调用 usmart_scan 函数。如果为 0，那么需要用户需要自行间隔一定时间（100ms
左右为宜）调用一次 usmart_scan 函数，以实现串口数据处理。 注意：如果要使用函数执行 时
ALIENTEK 战舰 STM32F103 V3 开发板教程
237
STM32 F1 开发指南( ( 寄存器 版) )
间 统计功能（runtime 1） ） ，置 则必须设置 USMART_ENTIMX_SCAN 为 为 1。 。 另外，为了让统计时
到 间精确到 0.1ms ，定时器的计数时钟频率必须设置为 10Khz ，否则时间就不是 0.1ms 了。
第三和第四个函数仅用于服务 USMART 的函数执行时间统计功能（串口指令：runtime 1），
分别是：usmart_reset_runtime 和 usmart_get_runtime，这两个函数代码如下：

</pre>
<img src="../../src/img/singlechip/stm-usmart-3.png">
<pre>这里我们利用定时器 4 来做执行时间计算，usmart_reset_runtime 函数在每次 USMART 调
用函数之前执行，清除计数器，然后在函数执行完之后，调用 usmart_get_runtime 获取整个函
数的运行时间。由于 usmart 调用的函数，都是在中断里面执行的，所以我们不太方便再用定时
器的中断功能来实现定时器溢出统计，因此，USMART 的函数执行时间统计功能，最多可以统
计定时器溢出 1 次的时间，对 STM32F1 的定时器 4，该定时器是 16 位的，最大计数是 65535，
而由于我们定时器设置的是 0.1ms 一个计时周期（10Khz），所以最长计时时间是：
65535*2*0.1ms=13.1 秒。也就是说，如果函数执行时间超过 13.1 秒，那么计时将不准确。
最后一个是 usmart_scan 函数，该函数用于执行 usmart 扫描，该函数需要得到两个参量，
第一个是从串口接收到的数组（USART_RX_BUF），第二个是串口接收状态（USART_RX_STA）。
接收状态包括接收到的数组大小，以及接收是否完成。该函数代码如下：</pre>
<img src="../../src/img/singlechip/stm-usmart-4.png">
<img src="../../src/img/singlechip/stm-usmart-5.png">
<pre>该函数的执行过程：先判断串口接收是否完成（USART_RX_STA 的最高位是否为 1），如
果完成，则取得串口接收到的数据长度（USART_RX_STA 的低 14 位），并在末尾增加结束符，
再执行解析，解析完之后清空接收标记（USART_RX_STA 置零）。如果没执行完成，则直接跳
过，不进行任何处理。
完成这几个函数的移植，你就可以使用 USMART 了。不过，需要注意的是，usmart 同外
部的互交，一般是通过 usmart_dev 结构体实现，所以 usmart_init 和 usmart_scan 的调用分别是
通过：usmart_dev.init 和 usmart_dev.scan 实现的。
下面，我们将在第十八章实验的基础上，移植USMART，并通过USMART调用一些TFTLCD
的内部函数，让大家初步了解 USMART 的使用。
打开上一章的工程，复制 USMART 文件夹（该文件夹可以在：光盘→标准例程-寄存器版
本→实验 14 USMART 调试组件实验 里面找到）到本工程文件夹下面，如图 19.3.1 所示：</pre>

<img src="../../src/img/singlechip/stm-usmart-6.png">
<img src="../../src/img/singlechip/stm-usmart-7.png">
<pre>由于 USMART 默认提供了 STM32F1 的 TIM4 中断初始化设置代码，我们只需要在 usmart.h
里面设置 USMART_ENTIMX_SCAN 为 1，即可完成 TIM4 的设置，通过 TIM4 的中断服务函
数，调用 usmart_dev.scan()（就是 usmart_scan 函数），实现 usmart 的扫描。此部分代码我们就
不列出来了，请参考 usmart.c。
此时，我们就可以使用 USMART 了，不过在主程序里面还得执行 usmart 的初始化，另外
还需要针对你自己想要被 USMART 调用的函数在 usmart_config.c 里面进行添加。下面先介绍
如何添加自己想要被 USMART 调用的函数，打开 usmart_config.c，如图 19.3.3 所示</pre>
<img src="../../src/img/singlechip/stm-usmart-8.png">
<pre>这里的添加函数很简单，只要把函数所在头文件添加进来，并把函数名按上图所示的方式
增加即可，默认我们添加了两个函数：delay_ms 和 delay_us。另外，read_addr 和 write_addr 属
于 usmart 自带的函数，用于读写指定地址的数据，通过配置 USMART_USE_WRFUNS，可以
使能或者禁止这两个函数。
这里我们根据自己的需要按上图的格式添加其他函数，添加完之后如图 19.3.4 所示：</pre>
<img src="../../src/img/singlechip/stm-usmart-9.png">
<pre>上图中，我们添加了 lcd.h，并添加了很多 LCD 函数，最后我们还添加了 led_set 和 test_fun
两个函数，这两个函数在 test.c 里面实现，代码如下：</pre>


<img src="../../src/img/singlechip/stm-usmart-10.png">
<pre>led_set 函数，用于设置 LED1 的状态，而第二个函数 test_fun 则是测试 USMART 对函数参
数的支持的，test_fun 的第一个参数是函数，在 USMART 里面也是可以被调用的。
在添加完函数之后，我们修改 main 函数，如下：</pre>
<img src="../../src/img/singlechip/stm-usmart-11.png">
<img src="../../src/img/singlechip/stm-usmart-12.png">
<img src="../../src/img/singlechip/stm-usmart-13.png">

<pre>上图中 list、id、？、help、hex、dec 和 runtime 都属于 usmart 自带的系统命令。下面我们
简单介绍下这几个命令：
上图中 list、id、help、hex、dec 和 runtime 都属于 usmart 自带的系统命令，点击后方的数
字按钮，即可发送对应的指令。下面我们简单介绍下这几个命令：
list，该命令用于打印所有 usmart 可调用函数。发送该命令后，串口将受到所有能被 usmart
调用得到函数，如图 19.4.1 所示。
id，该指令用于获取各个函数的入口地址。比如前面写的 test_fun 函数，就有一个函数参数，
我们需要先通过 id 指令，获取 led_set 函数的 id（即入口地址），然后将这个 id 作为函数参数，
传递给 test_fun。
help（或者‘ ？’也可以），发送该指令后，串口将打印 usmart 使用的帮助信息。
hex 和 dec，这两个指令可以带参数，也可以不带参数。当不带参数的时候，hex 和 dec 分
别用于设置串口显示数据格式为 16 进制/10 进制。当带参数的时候，hex 和 dec 就执行进制转
换，比如输入：hex 1234，串口将打印：HEX:0X4D2，也就是将 1234 转换为 16 进制打印出来。
又比如输入：dec 0X1234，串口将打印：DEC:4660，就是将 0X1234 转换为 10 进制打印出来。
runtime 指令，用于函数执行时间统计功能的开启和关闭，发送：runtime 1，可以开启函数
执行时间统计功能；发送：runtime 0，可以关闭函数执行时间统计功能。函数执行时间统计功
能，默认是关闭的。
大家可以亲自体验下这几个系统指令，不过要注意，所有的指令都是大小写敏感的，不要
写错哦。
接下来，我们将介绍如何调用 list 所打印的这些函数，先来看一个简单的 delay_ms 的调用，
我们分别输入 delay_ms(1000)和 delay_ms(0x3E8)，如图 19.4.2 所示：
</pre>
<img src="../../src/img/singlechip/stm-usmart-14.png">
<pre>从上图可以看出，delay_ms(1000)和 delay_ms(0x3E8)的调用结果是一样的，都是延时
ALIENTEK 战舰 STM32F103 V3 开发板教程
244
STM32 F1 开发指南( ( 寄存器 版) )
1000ms，因为 usmart 默认设置的是 hex 显示，所以看到串口打印的参数都是 16 进制格式的，
大家可以通过发送 dec 指令切换为十进制显示。另外，由于 USMART 对调用函数的参数大小写
不敏感，所以参数写成：0X3E8 或者 0x3e8 都是正确的。另外，发送：runtime 1，开启运行时
间统计功能，从测试结果看，USMART 的函数运行时间统计功能，是相当准确的。
我们再看另外一个函数，LCD_ShowString 函数，该函数用于显示字符串，我们通过串口输
入：LCD_ShowString(20,200,200,100,16,"This is a test for usmart!!")，如图 19.4.3 所示：</pre>
<img src="../../src/img/singlechip/stm-usmart-15.png">

<pre>该函数用于在指定区域，显示指定字符串，发送给开发板后，我们可以看到 LCD 在我们指
定的地方显示了：This is a test for usmart!! 这个字符串。
其他函数的调用，也都是一样的方法，这里我们就不多介绍了，最后说一下带有函数参数
的函数的调用。我们将led_set函数作为 test_fun的参数，通过在test_fun里面调用led_set函数，
实现对 DS1(LED1)的控制。前面说过，我们要调用带有函数参数的函数，就必须先得到函数参
数的入口地址（id），通过输入 id 指令，我们可以得到 led_set 的函数入口地址是：0X080052C9(注
意：这个地址要以实际串口输出结果为准)，所以，我们在串口输入：test_fun(0X080052C9,0)，
就可以控制 DS1 亮了。如图 19.4.4 所示：</pre>

<img src="../../src/img/singlechip/stm-usmart-16.png">
<pre>在开发板上，我们可以看到，收到串口发送的 test_fun(0X080052C9,0)后，开发板的 DS1
亮了，然后大家可以通过发送test_fun(0X080052C9,1)，来关闭DS1。说明我们成功的通过test_fun
函数调用 led_set，实现了对 DS1 的控制。也就验证了 USMART 对函数参数的支持。</pre>

</body>
</html>