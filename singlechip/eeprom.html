<!DOCTYPE html>
<html lang="en">
 <head>
    <title>EEPROM</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width initial-scale=1"/>
    <link rel="shortcut icon" type="image/x-icon" href="../../src/img/cover/cover_title.png"/>
    <!-- Prism -->
    <link rel="stylesheet" href="../../css/prism.css">
    <script src="../../js/prism.js"></script>
    <!-- 新 Bootstrap4 核心 CSS 文件 -->
    <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
    <!-- jQuery文件。务必在bootstrap.min.js 之前引入 -->
    <script src="https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js"></script>
    <!-- bootstrap.bundle.min.js 用于弹窗、提示、下拉菜单，包含了 popper.min.js -->
    <script src="https://cdn.staticfile.org/popper.js/1.15.0/umd/popper.min.js"></script>
    <!-- 最新的 Bootstrap4 核心 JavaScript 文件 -->
    <script src="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>
    <!-- My style.css-->
    <link rel="stylesheet" href="../../css/bootstrap-m-style.css">
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>

<a href="../index/singlechip.html">
<svg class="bi bi-arrow-left-square" width="3em" height="3em" viewBox="0 0 16 16" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
  <path fill-rule="evenodd" d="M14 1H2a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>
  <path fill-rule="evenodd" d="M8.354 11.354a.5.5 0 0 0 0-.708L5.707 8l2.647-2.646a.5.5 0 1 0-.708-.708l-3 3a.5.5 0 0 0 0 .708l3 3a.5.5 0 0 0 .708 0z"/>
  <path fill-rule="evenodd" d="M11.5 8a.5.5 0 0 0-.5-.5H6a.5.5 0 0 0 0 1h5a.5.5 0 0 0 .5-.5z"/>
</svg>
</a>

<br>
<div class="m-label">EEPROM</div>
<pre><code class="language-html line-numbers">24C02，是一个容量大小是 2Kbits，也就是 256 个字节的 EEPROM。一般情况下，EEPROM 拥有 30 万到 100 万次的寿命，也就是它可以反复写入 30-100 万次，而读取次数是无限的。
24C02 是一个基于 I 2 C 通信协议的器件，因此从现在开始，我们的 I 2 C 和我们的 EEPROM就要合体了。但是大家要分清楚，I 2 C 是一个通信协议，它拥有严密的通信时序逻辑要求，而 EEPROM 是一个器件，只是这个器件采样了 I 2 C 协议的接口与单片机相连而已，二者并没有必然的联系，EEPROM 可以用其它接口，I 2 C 也可以用在其它很多器件上

14.3.1 EEPROM 单字节读写操作时序
1、EEPROM 写数据流程
第一步，首先是 I 2 C 的起始信号，接着跟上首字节，也就是我们前边讲的 I 2 C 的器件地址，并且在读写方向上选择“写”操作。
第二步，发送数据的存储地址。24C02 一共 256 个字节的存储空间，地址从 0x00～0xFF，我们想把数据存储在哪个位置，此刻写的就是哪个地址。
第三步，发送要存储的数据第一个字节、第二个字节„„注意在写数据的过程中，EEPROM 每个字节都会回应一个“应答位 0”，来告诉我们写 EEPROM 数据成功，如果没有回应答位，说明写入不成功。在写数据的过程中，每成功写入一个字节，EEPROM 存储空间的地址就会自动加 1，当加到 0xFF 后，再写一个字节，地址会溢出又变成了 0x00。
2、EEPROM 读数据流程
第一步，首先是 I 2 C 的起始信号，接着跟上首字节，也就是我们前边讲的 I 2 C 的器件地址，并且在读写方向上选择“写”操作。这个地方可能有同学会诧异，我们明明是读数据为何方向也要选“写”呢？刚才说过了，24C02 一共有 256 个地址，我们选择写操作，是为了把所要读的数据的存储地址先写进去，告诉 EEPROM 我们要读取哪个地址的数据。这就如同我们打电话，先拨总机号码（EEPROM 器件地址），而后还要继续拨分机号码（数据地址），而拨分机号码这个动作，主机仍然是发送方，方向依然是“写”。
第二步，发送要读取的数据的地址，注意是地址而非存在 EEPROM 中的数据，通知EEPROM 我要哪个分机的信息。
第三步，重新发送 I 2 C 起始信号和器件地址，并且在方向位选择“读”操作。
这三步当中，每一个字节实际上都是在“写”，所以每一个字节 EEPROM 都会回应一个“应答位 0”。
第四步，读取从器件发回的数据，读一个字节，如果还想继续读下一个字节，就发送一个“应答位 ACK(0)”，如果不想读了，告诉 EEPROM，我不想要数据了，别再发数据了，那就发送一个“非应答位 NAK(1)”。
和写操作规则一样，我们每读一个字节，地址会自动加 1，那如果我们想继续往下读，给 EEPROM 一个 ACK(0)低电平，那再继续给 SCL 完整的时序，EEPROM 会继续往外送数据。如果我们不想读了，要告诉 EEPROM 不要数据了，那我们直接给一个 NAK(1)高电平即可。这个地方大家要从逻辑上理解透彻，不能简单的靠死记硬背了，一定要理解明白。
梳理一下几个要点：A、在本例中单片机是主机，24C02 是从机；
                              B、无论是读是写，SCL 始终都是由主机控制的；
                              C、写的时候应答信号由从机给出，表示从机是否正确接收了数据；
                              D、读的时候应答信号则由主机给出，表示是否继续读下去。

驱动24C01的过程
(1) 向24C01写数据
	• 发起始信号
	• 寻址24C01：写1010（A1）（A2）（A3）0
	• 接收Acknowledge
	• 发送写入的地址：0x00~0x80
	• 发送数据
	• 发停止信号
(2)读取24C01的数据
	• 发起始信号
	• 寻址24C01：写1010（A1）（A2）（A3）0
	• 接收Acknowledge
	• 发起始信号
	• 发送读命令：读1010（A1）（A2）（A3）1
	• 接收数据
	• 发送Acknowledge
	• 发结束信号
</code></pre>

</body>
</html>