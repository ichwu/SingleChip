<!DOCTYPE html>
<html lang="en">
 <head>
    <title>定时器中断</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width initial-scale=1"/>
    <link rel="shortcut icon" type="image/x-icon" href="../../src/img/cover/cover_title.png"/>
    <!-- Prism -->
    <link rel="stylesheet" href="../../css/prism.css">
    <script src="../../js/prism.js"></script>
    <!-- 新 Bootstrap4 核心 CSS 文件 -->
    <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
    <!-- jQuery文件。务必在bootstrap.min.js 之前引入 -->
    <script src="https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js"></script>
    <!-- bootstrap.bundle.min.js 用于弹窗、提示、下拉菜单，包含了 popper.min.js -->
    <script src="https://cdn.staticfile.org/popper.js/1.15.0/umd/popper.min.js"></script>
    <!-- 最新的 Bootstrap4 核心 JavaScript 文件 -->
    <script src="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>
    <!-- My style.css-->
    <link rel="stylesheet" href="../../css/bootstrap-m-style.css">
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>

<a href="../index/singlechip.html">
<svg class="bi bi-arrow-left-square" width="3em" height="3em" viewBox="0 0 16 16" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
  <path fill-rule="evenodd" d="M14 1H2a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>
  <path fill-rule="evenodd" d="M8.354 11.354a.5.5 0 0 0 0-.708L5.707 8l2.647-2.646a.5.5 0 1 0-.708-.708l-3 3a.5.5 0 0 0 0 .708l3 3a.5.5 0 0 0 .708 0z"/>
  <path fill-rule="evenodd" d="M11.5 8a.5.5 0 0 0-.5-.5H6a.5.5 0 0 0 0 1h5a.5.5 0 0 0 .5-.5z"/>
</svg>
</a>

<br>
<div class="m-label">定时器中断</div>

<pre>STM32 的通用定时器是一个通过可编程预分频器（PSC）驱动的 16 位自动装载计数器（CNT）构成。STM32 的通用定时器可以被用于：测量输入信号的脉冲长度(输入捕获)或者产生输出波形(输出比较和 PWM)等。 使用定时器预分频器和 RCC 时钟控制器预分频器，脉冲长度和波形周期可以在几个微秒到几个毫秒间调整。STM32 的每个通用定时器都是完全独立的，没有互相共享的任何资源。
STM3 的通用 TIMx (TIM2、TIM3、TIM4 和 TIM5)定时器功能包括：
1)16 位向上、向下、向上/向下自动装载计数器（TIMx_CNT）。
2)16 位可编程(可以实时修改)预分频器(TIMx_PSC)，计数器时钟频率的分频系数为 1～65535 之间的任意数值。
3）4 个独立通道（TIMx_CH1~4），这些通道可以用来作为：
	A．输入捕获
	B．输出比较
	C．PWM 生成(边缘或中间对齐模式)
	D．单脉冲模式输出
4）可使用外部信号（TIMx_ETR）控制定时器和定时器互连（可以用 1 个定时器控制另外一个定时器）的同步电路。
5）如下事件发生时产生中断/DMA：
	A．更新：计数器向上溢出/向下溢出，计数器初始化(通过软件或者内部/外部触发)
	B．触发事件(计数器启动、停止、初始化或者由内部/外部触发计数)
	C．输入捕获
	D．输出比较
	E．支持针对定位的增量(正交)编码器和霍尔传感器电路
	F．触发输入作为外部时钟或者按周期的电流管理

控制寄存器 1（TIMx_CR1）
</pre>

<img src="../../src/img/singlechip/stm-timer-interrupt-1.png">
<pre>在本实验中，我们只用到了 TIMx_CR1 的最低位，也就是计数器使能位，该位必须置 1，才能让定时器开始计数
DMA/中断使能寄存器（TIMx_DIER）</pre>
<img src="../../src/img/singlechip/stm-timer-interrupt-2.png">

<pre>第 0 位，该位是更新中断允许位，本章用到的是定时器的更新中断，所以该位要设置为 1，来允许由于更新事件所产生的中断。
预分频寄存器（TIMx_PSC）</pre>
<img src="../../src/img/singlechip/stm-timer-interrupt-3.png">

<pre>这里，定时器的时钟来源有 4 个：
1）内部时钟（CK_INT）
2）外部时钟模式 1：外部输入脚（TIx）
3）外部时钟模式 2：外部触发输入（ETR）
4）内部触发输入（ITRx）：使用 A 定时器作为 B 定时器的预分频器（A 为 B 提供时钟）。
这些时钟，具体选择哪个可以通过 TIMx_SMCR 寄存器的相关位来设置。这里的 CK_INT时钟是从 APB1 倍频的来的，除非 APB1 的时钟分频数设置为 1，否则通用定时器 TIMx 的时钟是 APB1 时钟的 2 倍，当 APB1 的时钟不分频的时候，通用定时器 TIMx 的时钟就等于 APB1的时钟。这里还要注意的就是高级定时器的时钟不是来自 APB1，而是来自 APB2 的。

这里顺带介绍一下 TIMx_CNT 寄存器，该寄存器是定时器的计数器，该寄存器存储了当前定时器的计数值。

接着我们介绍自动重装载寄存器（TIMx_ARR），该寄存器在物理上实际对应着 2 个寄存器。
一个是程序员可以直接操作的，另外一个是程序员看不到的，这个看不到的寄存器在《STM32中文参考手册》里面被叫做影子寄存器。事实上真正起作用的是影子寄存器。根据 TIMx_CR1寄存器中 APRE 位的设置：APRE=0 时，预装载寄存器的内容可以随时传送到影子寄存器，此时 2 者是连通的；而 APRE=1 时，在每一次更新事件（UEV）时，才把预装在寄存器的内容传送到影子寄存器。
自动重装载寄存器的各位描述如图 13.1.4 所示：
</pre>
<img src="../../src/img/singlechip/stm-timer-interrupt-4.png">
<p>状态寄存器（TIMx_SR）</p>
<img src="../../src/img/singlechip/stm-timer-interrupt-5.png">
<pre>该寄存器用来标记当前与定时器相关的各种事件/中断是否发生。
TIMx_ SR 寄存器，我们同样只用到了最低位，当计数器 CNT 被重新初始化的时候，产生更新中断标记，通过这个中断标志位，就可以知道产生中断的类型。


以通用定时器 TIM3 为实例，来说明要经过哪些步骤，才能达到这个要求，并产生中断。
1 ）TIM3 时钟使能。
这里我们通过 APB1ENR 的第 1 位来设置 TIM3 的时钟，因为 Stm32_Clock_Init 函数里面把APB1的分频设置为2了，所以我们的TIM3时钟就是APB1时钟的2倍，等于系统时钟（72M）。
2 ）设置 TIM3_ARR 和 和 TIM3_PSC 的值。
通过这两个寄存器，我们来设置自动重装的值，以及分频系数。这两个参数加上时钟频率就决定了定时器的溢出时间。
3 ）设置 TIM3_DIER 允许更新中断。
因为我们要使用 TIM3 的更新中断，所以设置 DIER 的 UIE 位为 1，使能更新中断。
4 ）允许 TIM3 工作。
光配置好定时器还不行，没有开启定时器，照样不能用。我们在配置完后要开启定时器，
通过 TIM3_CR1 的 CEN 位来设置。
5 ）TIM3 中断分组设置。
在定时器配置完了之后，因为要产生中断，必不可少的要设置 NVIC 相关寄存器，以使能TIM3 中断。
6 ）编写中断服务函数。
在最后，还是要编写定时器中断服务函数，通过该函数来处理定时器产生的相关中断。在中断产生后，通过状态寄存器的值来判断此次产生的中断属于什么类型。然后执行相关的操作，我们这里使用的是更新（溢出）中断，所以在状态寄存器 SR 的最低位。在处理完中断之后应
该向 TIM3_SR 的最低位写 0，来清除该中断标志。

通过以上几个步骤，我们就可以达到我们的目的了，使用通用定时器的更新中断，来控制DS1 的亮灭

time.c
</pre>

<img src="../../src/img/singlechip/stm-timer-interrupt-6.png">
<img src="../../src/img/singlechip/stm-timer-interrupt-7.png">

<pre>该文件下包含一个中断服务函数和一个定时器 3 中断初始化函数，中断服务函数比较简单，在每次中断后，判断 TIM3 的中断类型，如果中断类型正确，则执行 LED1（DS1）的取反。
TIM3_Int_Init 函数就是执行我们上面介绍的那 5 个步骤，使得 TIM3 开始工作，并开启中断。该函数的 2 个参数用来设置 TIM3 的溢出时间。因为我们在 Stm32_Clock_Init 函数里面已经初始化 APB1 的时钟为 2 分频，所以 APB1 的时钟为 36M，而从 STM32F1 的内部时钟树图（图 5.2.2.1）得知：当 APB1 的时钟分频数为 1 的时候，TIM2~7 的时钟为 APB1 的时钟，而如果 APB1 的时钟分频数不为 1，那么 TIM2~7 的时钟频率将为 APB1 时钟的两倍。因此，TIM3的时钟为 72M，再根据我们设计的 arr 和 psc 的值，就可以计算中断时间了。计算公式如下：
Tout= ((arr+1)*(psc+1))/Tclk；
Tclk：TIM3 的输入时钟频率（单位为 Mhz）。
Tout：TIM3 溢出时间（单位为 us）。

time.h
</pre>

<img src="../../src/img/singlechip/stm-timer-interrupt-8.png">
<pre>如果没有错误，我们将看 DS0 不停闪烁（每 400ms 闪烁一次），而 DS1 也是不停的闪烁，但是闪烁时间较 DS0 慢（1s 一次）
</pre>
</body>
</html>