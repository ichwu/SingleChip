<!DOCTYPE html>
<html lang="en">
 <head>
    <title>Modbus</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width initial-scale=1"/>
    <link rel="shortcut icon" type="image/x-icon" href="../../src/img/cover/cover_title.png"/>
    <!-- Prism -->
    <link rel="stylesheet" href="../../css/prism.css">
    <script src="../../js/prism.js"></script>
    <!-- 新 Bootstrap4 核心 CSS 文件 -->
    <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
    <!-- jQuery文件。务必在bootstrap.min.js 之前引入 -->
    <script src="https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js"></script>
    <!-- bootstrap.bundle.min.js 用于弹窗、提示、下拉菜单，包含了 popper.min.js -->
    <script src="https://cdn.staticfile.org/popper.js/1.15.0/umd/popper.min.js"></script>
    <!-- 最新的 Bootstrap4 核心 JavaScript 文件 -->
    <script src="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>
    <!-- My style.css-->
    <link rel="stylesheet" href="../../css/bootstrap-m-style.css">
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>

<a href="../index/singlechip.html">
<svg class="bi bi-arrow-left-square" width="3em" height="3em" viewBox="0 0 16 16" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
  <path fill-rule="evenodd" d="M14 1H2a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>
  <path fill-rule="evenodd" d="M8.354 11.354a.5.5 0 0 0 0-.708L5.707 8l2.647-2.646a.5.5 0 1 0-.708-.708l-3 3a.5.5 0 0 0 0 .708l3 3a.5.5 0 0 0 .708 0z"/>
  <path fill-rule="evenodd" d="M11.5 8a.5.5 0 0 0-.5-.5H6a.5.5 0 0 0 0 1h5a.5.5 0 0 0 .5-.5z"/>
</svg>
</a>

<br>
<div class="m-label">Modbus</div>
<pre>我们前边学习 UART、I 2 C、SPI 这些通信协议，都是最底层的协议，是“位”级别的协议
Modbus通信协议和 UART、I 2 C、SPI通信协议不同的是，这种通信协议是字节级别的，叫做应用层通信协议。

Modbus 协议是应用于电子控制器上的一种通用语言。通过此协议，控制器相互之间、控制器经由网络（例如以太网）和其他设备之间可以通信，已经成为一种工业标准。有了它，不同厂商生产的控制设备可以连成工业网络，进行集中监控。这种协议定义了一种控制器能够认识使用的数据结构，而不管它们是经过何种网络进行通信的。它描述了控制器请求访问其它设备的过程，如何回应来自其它设备的请求，以及怎样侦测错误记录，它制定了通信数据的格局和内容的公共格式。
在进行多机通信的时候，Modbus 协议规定每个控制器必须要知道它们的设备地址，识别按照地址发送过来的数据，决定是否要产生动作，产生何种动作，如果要回应，控制器将生成的反馈信息用 Modbus 协议发出。
Modbus 协议允许在各种网络体系结构内进行简单通信，每种设备（PLC、人机界面、控制面板、驱动程序、输入输出设备等）都能使用 Modbus 协议来启动远程操作，一些网关允许在几种使用 Modbus 协议的总线或网络之间的通信，如图 18-4 所示。</pre>

<img src="../../src/img/singlechip/modbus-1.png">

<pre>Modbus 协议的整体架构和格式比较复杂和庞大，在我们的课程里，我们重点介绍数据帧结构和数据通信控制方式，作为一个入门级别的了解。如果大家要详细了解，或者使用Modbus 开发相关设备，可以查阅相关的国标文件再进行深入学习。

Modbus 有两种通信传输方式，一种是 ASCII 模式，一种是 RTU 模式。由于 ASCII 模式的数据字节是 7bit 数据位，51 单片机无法实现，而且实际应用的也比较少，所以这里我们只用 RTU 模式。两种模式相似，会用一种另外一种也就会了。一条典型的 RTU 数据帧如图 18-5所示。
</pre>

<img src="../../src/img/singlechip/modbus-2.png">

<pre>与之前我们讲解实用串口通信程序时用的原理相同，一次发送的数据帧必须是作为一连续的数据流进行传输。我们在实用串口通信程序中采用的方法是定义 30ms，如果数据接收
时超过了 30ms 还没有接收到下一个字节，我们就认为这次的数据结束。而 Modbus 的 RTU模式规定不同数据帧之间的间隔是 3.5 个字节通信时间以上。如果在一帧数据完成之前有超过 3.5 个字节时间的停顿，接收设备将刷新当前的消息并假定下一个字节是一个新的数据帧的开始。同样的，如果一个新消息在小于 3.5 个字节时间内接着前边一个数据开始，接收设备将会认为它是前一帧数据的延续。这将会导致一个错误，因此大家看 RTU 数据帧最后还有16bit 的 CRC 校验。
起始位和结束符：图 18-5 上代表的是一个数据帧，前后都至少有 3.5 个字节的时间间隔，起始位和结束符实际上没有任何数据，T1-T2-T3-T4 代表的是时间间隔 3.5 个字节以上的时间，而真正有意义的第一个字节是设备地址。
设备地址：很多同学不理解，在多机通信的时候，数据那么多，我们依靠什么判断这个数据帧是哪个设备的呢？没错，就是依靠这个设备地址字节。每个设备都有一个自己的地址，
当设备接收到一帧数据后，程序首先对设备地址字节进行判断比较，如果与自己的地址不同，则对这帧数据直接不予理会，如果与自己的地址相同，就要对这帧数据进行解析，按照之后的功能码执行相应的功能。如果地址是 0x00，则认为是一个广播命令，就是所有的从机设备都要执行的指令。
功能代码：在第二个字节功能代码字节中，Modbus 规定了部分功能代码，此外也保留了一部分功能代码作为备用或者用户自定义，这些功能码大家不需要去记忆，甚至都不用去
看，直到你用到的那天再过来查这个表格即可，如表 18-1 所示。
</pre>

<img src="../../src/img/singlechip/modbus-3.png">
<img src="../../src/img/singlechip/modbus-4.png">

<pre>程序对功能码的处理，就是来检测这个字节的数值，然后根据其数值来做相应的功能处理。
数据：跟在功能代码后边的是 n 个 8bit 的数据。这个 n 值的到底是多少，是功能代码来确定的，不同的功能代码后边跟的数据数量不同。举个例子，如果功能码是 0x03，也就是读保持寄存器，那么主机发送数据 n 的组成部分就是：2 个字节的寄存器起始地址，加 2 个字节的寄存器数量 N。从机数据 n 的组成部分是：1 个字节的字节数，因为我们回复的寄存器的值是 2 个字节，所以这个字节数也就是 2N 个，再加上 2N 个寄存器的值，如图 18-6 所示。
</pre>

<img src="../../src/img/singlechip/modbus-5.png">

<pre>CRC 校验：CRC 校验是一种数据算法，是用来校验数据对错的。CRC 校验函数把一帧数据除最后两个字节外，前边所有的字节进行特定的算法计算，计算完后生成了一个 16bit的数据，作为 CRC 校验码，添加在一帧数据的最后。接收方接收到数据后，同样会把前边的字节进行 CRC 计算，计算完了再和发过来的 16bit 的 CRC 数据进行比较，如果相同则认为数据正常，没有出错，如果比较不相同，则说明数据在传输中发生了错误，这帧数据将被丢弃，就像没收到一样，而发送方会在得不到回应后做相应的处理错误处理。
RTU 模式的每个字节的位是这样分布的：1 个起始位、8 个数据位，最小有效位先发送、1 个奇偶校验位（如果无校验则没有这一位）、1 位停止位（有校验位时）或者 2 个停止位（无校验位时）。</pre>



</body>
</html>