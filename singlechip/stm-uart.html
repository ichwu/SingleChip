<!DOCTYPE html>
<html lang="en">
 <head>
    <title>UART</title>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width initial-scale=1"/>
    <link rel="shortcut icon" type="image/x-icon" href="../../src/img/cover/cover_title.png"/>
    <!-- Prism -->
    <link rel="stylesheet" href="../../css/prism.css">
    <script src="../../js/prism.js"></script>
    <!-- 新 Bootstrap4 核心 CSS 文件 -->
    <link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/css/bootstrap.min.css">
    <!-- jQuery文件。务必在bootstrap.min.js 之前引入 -->
    <script src="https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js"></script>
    <!-- bootstrap.bundle.min.js 用于弹窗、提示、下拉菜单，包含了 popper.min.js -->
    <script src="https://cdn.staticfile.org/popper.js/1.15.0/umd/popper.min.js"></script>
    <!-- 最新的 Bootstrap4 核心 JavaScript 文件 -->
    <script src="https://cdn.staticfile.org/twitter-bootstrap/4.3.1/js/bootstrap.min.js"></script>
    <!-- My style.css-->
    <link rel="stylesheet" href="../../css/bootstrap-m-style.css">
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>
</head>
<body>

<a href="../index/singlechip.html">
<svg class="bi bi-arrow-left-square" width="3em" height="3em" viewBox="0 0 16 16" fill="currentColor" xmlns="http://www.w3.org/2000/svg">
  <path fill-rule="evenodd" d="M14 1H2a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>
  <path fill-rule="evenodd" d="M8.354 11.354a.5.5 0 0 0 0-.708L5.707 8l2.647-2.646a.5.5 0 1 0-.708-.708l-3 3a.5.5 0 0 0 0 .708l3 3a.5.5 0 0 0 .708 0z"/>
  <path fill-rule="evenodd" d="M11.5 8a.5.5 0 0 0-.5-.5H6a.5.5 0 0 0 0 1h5a.5.5 0 0 0 .5-.5z"/>
</svg>
</a>

<br>
<div class="m-label">UART</div>
<pre>利用串口 1 不停的打印信息到电脑上，同时接收从串口发过来的数据，把发送过来的数据直接送回给电脑。

1，串口时钟使能。串口作为 STM32 的一个外设，其时钟由外设时钟使能寄存器控制，这里我们使用的串口1是在APB2ENR寄存器的第14位。
                   就是除了串口 1 的时钟使能在 APB2ENR 寄存器，其他串口的时钟使能位都在 APB1ENR 寄存器。
2，串口复位。当外设出现异常的时候可以通过复位寄存器里面的对应位设置，实现该外设的复位，然后重新配置这个外设达到让其重新工作的目的。一般在系统刚开始配置外设的时候，都会先执行复位该外设的操作。串口 1 的复位是通过配置 APB2RSTR 寄存器的第 14 位来实现的。

APB2RSTR 寄存器的各位描述如图 9.1.1 所示：</pre>

<img src="../../src/img/singlechip/stm-uart-1.png">

<pre>3，串口波特率设置。每个串口都有一个自己独立的波特率寄存器 USART_BRR，通过设置该寄存器就可以达到配置不同波特率的目的。
4，串口控制。STM32 的每个串口都有 3 个控制寄存器 USART_CR1~3，这里我们只要用到 USART_CR1 就可以实现我们的功能了，

USART_CR1 寄存器的各位描述如图 9.1.2 所示：</pre>

<img src="../../src/img/singlechip/stm-uart-2.png">
<pre>
UE 为串口使能位，通过该位置 1，以使能串口。
M 为字长选择位，当该位为 0 的时候设置串口为 8 个字长外加 n 个停止位，停止位的个数（n）是根据 USART_CR2 的[13:12]位设置来决定的，默认为 0。
PCE 为校验使能位，设置为 0，则禁止校验，否则使能校验。
PS 为校验位选择，设置为 0 则为偶校验，否则为奇校验。
TXIE 为发送缓冲区空中断使能位，设置该位为 1，当 USART_SR 中的 TXE 位为1 时，将产生串口中断。
TCIE 为发送完成中断使能位，设置该位为 1，当 USART_SR 中的 TC位为 1 时，将产生串口中断。
RXNEIE 为接收缓冲区非空中断使能，设置该位为 1，当 USART_SR中的 ORE 或者 RXNE 位为 1 时，将产生串口中断。
TE 为发送使能位，设置为 1，将开启串口的发送功能。RE 为接收使能位，用法同 TE。

5，数据发送与接收。STM32 的发送与接收是通过数据寄存器 USART_DR 来实现的，这是一个双寄存器，包含了 TDR 和 RDR。
当向该寄存器写数据的时候，串口就会自动发送，当收到数据的时候，也是存在该寄存器内。

USART_DR寄存器的各位描述如图 9.1.3 所示</pre>
<img src="../../src/img/singlechip/stm-uart-3.png">
<pre>可以看出，虽然是一个 32 位寄存器，但是只用了低 9 位（DR[8：0]），其他都是保留。
DR[8：0]为串口数据，包含了发送或接收的数据。由于它是由两个寄存器组成的，一个给发送用(TDR)，一个给接收用(RDR)，该寄存器兼具读和写的功能。
TDR 寄存器提供了内部总线和输出移位寄存器之间的并行接口。
RDR 寄存器提供了输入移位寄存器和内部总线之间的并行接口。
当使能校验位(USART_CR1 中 PCE 位被置位)进行发送时，写到 MSB 的值(根据数据的长度不同，MSB 是第 7 位或者第 8 位)会被后来的校验位取代。
当使能校验位进行接收时，读到的 MSB 位是接收到的校验位。
6，串口状态。串口的状态可以通过状态寄存器 USART_SR 读取。

USART_SR 的各位描述如图 9.1.4 所示：</pre>
<img src="../../src/img/singlechip/stm-uart-4.png">
<pre>RXNE（读数据寄存器非空），当该位被置 1 的时候，就是提示已经有数据被接收到了，并且可以读出来了。
             这时候我们要做的就是尽快去读取 USART_DR，通过读 USART_DR 可以将该位清零，也可以向该位写 0，直接清除。
TC（发送完成），当该位被置位的时候，表示 USART_DR 内的数据已经被发送完成了。如果设置了这个位的中断，则会产生中断。
该位也有两种清零方式：1）读 USART_SR，写USART_DR。2）直接向该位写 0。</pre>
<img src="../../src/img/singlechip/stm-uart-5.png">

<pre>因为本章我们用不到按键和蜂鸣器等功能，所以把key.c和beep.c从工程→HARDWARE 组里面删除
删除方法（下同）：光标放 key.c 上→右键→Remove File‘key.c’即可删除（beep.c 删除方法一样），从减少工程代码量，节省空间，加快编译速度
然后在 SYSTEM 组下双击 usart.c，我们就可以看到该文件里面的代码，先介绍 uart_init 函数，该函数代码如下
</pre>

<img src="../../src/img/singlechip/stm-uart-6.png">
<img src="../../src/img/singlechip/stm-uart-7.png">

<pre>初始化串口的过程:先计算得到USART1->BRR 的内容。然后开始初始化串口引脚，然之后设置波特率和奇偶校验等。
这里需要注意一点，因为我们使用到了串口的中断接收，必须在 usart.h 里面设置EN_USART1_RX 为 1 （默认设置就是 1 的）。该函数才会配置中断使能，以及开启串口 1 的 NVIC中断。
这里我们把串口 1 中断放在组 2，优先级设置为组 2 里面的最低。
串口 1 的中断服务函数 USART1_IRQHandler，在 5.3.1 已经有详细介绍了，这里我们就不再介绍了。
介绍完了这两个函数，我们回到 test.c，在 test.c 里面编写如下代码：</pre>

<img src="../../src/img/singlechip/stm-uart-8.png">
<img src="../../src/img/singlechip/stm-uart-9.png">

<br>这段代码比较简单，重点看下以下两句
<img src="../../src/img/singlechip/stm-uart-10.png">

<pre>第一句，其实就是发送一个字节到串口，通过直接操作寄存器来实现的。第二句呢，就是我们在写了一个字节在 USART1->DR 之后，要检测这个数据是否已经被发送完成了，通过检测USART1->SR 的第 6 位，是否为 1 来决定是否可以开始第二个字节的发送
</pre>
<img src="../../src/img/singlechip/stm-uart-11.png">
<pre>从图 9.4.1 可以看出，STM32F1 的串口数据发送是没问题的了。但是，因为我们在程序上面设置了必须输入回车，串口才认可接收到的数据，所以必须在发送数据后再发送一个回车符，这里 XCOM 提供的发送方法是通过勾选发送新行实现，如图 9.4.1，只要勾选了这个选项，每次发送数据后，XCOM 都会自动多发一个回车(0X0D+0X0A)。设置好了发送新行，我们再在发送区输入你想要发送的文字，然后单击发送，可以得到如图 9.4.2 所示结果：</pre>
<img src="../../src/img/singlechip/stm-uart-12.png">


</body>
</html>